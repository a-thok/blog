[
  {
    "name": "blog-text-to-speech",
    "title": "为博客增加文章朗读功能",
    "date": " 2017-01-07",
    "tags": [
      "技术"
    ],
    "content": "### Web Speech API\r\n\r\nWeb Speech API是浏览器上一组相对较新的接口，包含Speech Recognition（语音识别）和Speech Synthesis（语音合成）两大部分。  \r\n简单地说，前者处理的是从语音到文本的转换；后者反之，处理的是从文本到语音的转换。\r\n\r\n本文所实现的文章朗读功能基于Speech Synthesis。\r\n\r\n### Speech Synthesis的基本使用\r\n\r\nSpeech Synthesis在全局暴露了两个接口，分别是`window.SpeechSynthesisUtterance`和`window.speechSynthesis`。\r\n\r\n#### window.SpeechSynthesisUtterance\r\n\r\n`SpeechSynthesisUtterance`是一个构造函数，用来生成语音实例。它接收一个字符串参数，即将要被转换成语音的文本内容：\r\n\r\n<pre><code class=\"language-javascript\">\r\n  const utterance = new SpeechSynthesisUtterance('Hello World');\r\n</code></pre>\r\n\r\n此参数并不是必须的，你也可以像下面这样做：\r\n\r\n<pre><code class=\"language-javascript\">\r\n  const utterance = new SpeechSynthesisUtterance();\r\n  utterance.text = 'Hello World';\r\n</code></pre>\r\n\r\n除了`text`以外，`SpeechSynthesisUtterance`的实例还提供了其它的一些属性让开发者控制合成语音的细节，比如音量、语速等。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  utterance.lang = 'zh-CN'; // 语种，默认等同于html标签的lang属性，如果此属性未设置，则等同于用户代理（浏览器）的设置\r\n  utterance.pitch = 1; // 音高，0 - 1，默认1\r\n  utterance.rate = 0.95; // 语速，0.1 - 10，默认1\r\n  utterance.volumn = 1; // 音量，0 - 1，默认1\r\n</code></pre>\r\n\r\n我们还可以监听实例的状态变化：\r\n\r\n<pre><code class=\"language-javascript\">\r\n  utterance.addEventListener('start', () => console.log('语音朗读已开始'));\r\n  utterance.addEventListener('end', () => console.log('语音朗读已结束'));\r\n</code></pre>\r\n\r\n#### window.speechSynthesis\r\n\r\n生成并配置好语音实例后，我们使用`speechSynthesis`来调用设备的语音服务。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  speechSynthesis.speak(utterance); // 开始朗读\r\n  speechSynthesis.pause(); // 暂停朗读\r\n  speechSynthesis.resume(); // 恢复朗读\r\n  speechSynthesis.cancel(); // 停止朗读\r\n</code></pre>\r\n\r\n多次调用`speak`将形成一个朗读队列，前一个实例朗读完成后继续朗读下一个实例。  \r\n一个设备上同一时间只能有一个实例正在朗读，因此`pause`与`resume`不需要指定参数，它们操作当前正在朗读的那个实例。  \r\n`cancel`将停止朗读并清空整个朗读队列。\r\n\r\n`speechSynthesis`上还有三个对应于以上操作的只读属性，让开发者获取语音朗读的状态。  \r\n其中`speaking`与`paused`分别判断是否处于朗读和暂停状态，`pending`则判断朗读队列中是否有等待朗读的语音实例。  \r\n\r\n我们还可以通过speechSynthesis.getVoices方法获取当前设备上可用的声音，它返回一个数组。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  const voices = speechSynthesis.getVoices();\r\n  utterance.voice = voices[0]; // 声音，默认将根据lang属性的值自动选择合适的声音\r\n</code></pre>\r\n\r\n### 实践\r\n\r\n整个Speech Synthesis接口的使用并不复杂，但使用中可能有一些细节需要注意。\r\n\r\n#### 移动端性能\r\n\r\n调用`speechSynthesis.speak`后，浏览器似乎要先对语音实例进行一些运算处理才能把最终的合成数据呈现给用户。  \r\n这个过程在桌面设备上比较短暂，但在性能相对较差的移动设备上，则会耗费相当的时间。我没有特地计算，但在我自己的*Lumia 830*上，朗读一段2000字左右的文章，感觉上至少等待了半分钟。这样的时长显然是不理想的，在等待过程中，用户可能会以为这个操作根本没有效果。因此需要在视图上给予用户某种形式的反馈，让用户知悉该操作的进度。  \r\n在这个博客里，我采用的方式是改变操作按钮的文本。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  // ......\r\n\r\n  const changeBtnText = text => readBtn.textContent = text;\r\n\r\n  // 根据语音实例的不同状态改变按钮的文本\r\n  utterance.addEventListener('start', () => changeBtnText('暂停朗读'));\r\n  utterance.addEventListener('pause', () => changeBtnText('继续朗读'));\r\n  utterance.addEventListener('resume', () => changeBtnText('暂停朗读'));\r\n  utterance.addEventListener('end', () => changeBtnText('重新朗读'));\r\n\r\n  // 点击朗读按钮时，把按钮文本更改为'处理中...'，让用户知道其操作有效果\r\n  readBtn.addEventListener('click', () => {\r\n    changeBtnText('处理中...');\r\n    window.speechSynthesis.speak(utterance);\r\n  });\r\n</code></pre>\r\n\r\n#### 声音选择\r\n\r\n不同的设备上`speechSynthesis.getVoices`会得到不同的结果。默认情况下，最简单、可靠的方式是不设置语音实例的`voice`属性，让浏览器自己选择合适的声音。  \r\n如果想让用户选择自己喜欢的声音，可以将声音列表以下拉框的形式呈现给用户，根据用户的选择去改变`voice`属性。  \r\n一个奇怪的问题是，同一台设备，我在*Opera（Blink）*下取到的声音列表是空的，但在*Edeg*下可以正常取到列表。因此这里多做了一个判断，只有取得到列表时才进行相应的操作。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  const voices = window.speechSynthesis.getVoices()\r\n    .filter(voice => voice.lang === 'zh-CN');\r\n\r\n  if (voices.length) {\r\n    const select = document.createElement('select');\r\n\r\n    const createAndAppendOption = (value, text) => {\r\n      const option = document.createElement('option');\r\n      option.value = value;\r\n      option.textContent = text;\r\n      select.appendChild(option);\r\n    };\r\n\r\n    voices\r\n      .forEach((voice, index) => {\r\n        createAndAppendOption(index, voice.name);\r\n      });\r\n\r\n    // .......\r\n  }\r\n</code></pre>\r\n\r\n用户可能会在朗读开始之前或朗读过程之中选择改变声音。后一种情况稍微复杂一些。  \r\n我原本的想法是，若改变声音时已经在朗读，就进行这样的三步操作：暂停朗读、改变`voice`、恢复朗读。但这个想法显然太乐观了。实践的结果是，语音实例一旦进入朗读队列，再去改变实例的属性并不会影响朗读的效果。  \r\n因此只能把队列清空，再把改变后的实例重新插入队列。这样会导致原本朗读到一半的文本必须从头开始朗读，但我暂时没有找到更好的办法。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  if (voices.length) {\r\n    // ......\r\n\r\n    select.addEventListener('change', (event) => {\r\n      const { value: index } = event.target;\r\n      const voice = index ? voices[index] : null;\r\n\r\n      if (speechSynthesis.speaking) {\r\n        speechSynthesis.cancel(); // 这里会改变按钮的文本\r\n        utterance.voice = voice;\r\n        setTimeout(() => {\r\n          // 把操作异步化确保这里的文本改变在其它文本改变后进行\r\n          changeBtnText('处理中...');\r\n          speechSynthesis.speak(utterance);\r\n        });\r\n      } else {\r\n        utterance.voice = voice;\r\n      }\r\n    });\r\n\r\n    // ......\r\n  }\r\n</code></pre>\r\n\r\n#### 非纯文本\r\n\r\n这里所说的*非纯文本*，指的是列表、表格、表单这种有语义格式的文本。代码块也可以算是*非纯文本*。这样的文本直接丢进接口里，朗读效果可能会和预期有差距，甚至没办法听懂。  \r\n如果要把朗读做得细致一些，可能要对这样的文本进行一些预处理。\r\n\r\n#### 兼容性\r\nSpeech Synthesis的兼容性还不错，根据[caniuse](http://caniuse.com/#search=Speech%20Synthesis)上的资料，基本上所有现代浏览器的桌面和移动版本都能完整地支持此接口。  \r\n\r\n对于不兼容的浏览器，我们可以做一个简单的回退。或者视图上直接不显示与此功能相关的元素；或者在用户操作后提示用户其浏览器不受支持。  \r\n可以使用`'speechSynthesis' in window`来检测不兼容的浏览器，也可以把相关的代码放入一个`try...catch`之中。\r\n\r\n\r\n### 感想\r\n\r\n* 相对于其它主流的语言，我个人感觉汉语的语速是偏慢的。用默认的语速朗读汉语文本，在我听来太快了，不太自然。因此把`rate`属性的值降低一些可能效果会更好。  \r\n不过不同的声音降低语速后的效果也不尽相同，同样是0.9的语速，我手机上的女声听起来还不错，男声就开始有点失真了。保险起见，`rate`的值最好不要偏离默认值太远。\r\n\r\n* 相比我印象里好多年前的情况，现在语音合成技术效果已经很不错了。但朗读的文本一长，机械感还是非常明显，特别是朗读散文、小说一类的东西。目前而言，这个技术可能比较适合用在说明文上。\r\n\r\n* 聆听自己写作的文本，会发现有些节奏和自己的期许不一样，比如自己感觉该停顿的地方没有停顿。机器是按照标点符号来停顿的，但我们写句子时，出于种种原因，标点符号的使用并不与文本的节奏完全吻合。如果我们根据机器的朗读去修改标点符号的使用，可能会使我们的文本在视觉上有更合适的节奏感。\r\n\r\n\r\n### 参考\r\n* [MDN - Web Speech API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API)\r\n* [Web apps that talk - Introduction to the Speech Synthesis API](https://developers.google.com/web/updates/2014/01/Web-apps-that-talk-Introduction-to-the-Speech-Synthesis-API)\r\n"
  },
  {
    "name": "hello-impostor",
    "title": "你好，骗子",
    "date": " 2016-12-31",
    "tags": [
      "技术",
      "生活"
    ],
    "content": "我是中途转行的，过去我所学的专业与所做的工作都和编程没有什么关系。\r\n\r\n但在大学里读书的时候，我对写代码这件事已经萌生了兴趣。虽然我忘记确切的起因了，那时候我通过网络上的材料自学了一些HTML和CSS，并对之产生强烈的兴趣。\r\n\r\n工作以后，我整个人的精神状态一直不太好，情绪也不太健康。最严重的那段时期，晚上睡觉时因为工作压力而做噩梦。\r\n\r\n不管一个人究竟如何看待工作，对大多数人而言，工作始终是他人生里最为重要的事情之一。醒着的大部分时间都在工作。所以一个人如果总是在工作上感到不顺心，就很难说享受生活。我开始觉得我正在从事的工作并不适合我，为了“拯救”我的生活，也许我应该在这件事上考虑别的可能性。因为之前有过自学基础的缘故，最后我决定在编程这条路上试一试。也许这样说有点戏剧性的夸张，但目前为止来看，这个决定几乎改变了我的人生。\r\n\r\n一开始我在一家公司里从事“切图”的工作，用HTML和CSS写简单的的静态页面，并尝试学习JS。这个过程并不顺利，有一阵子我甚至怀疑我做错了，我根本不是当程序员的材料。令我印象最深的一个细节是，我在网上寻找JS学习材料时，不断地遇到jQuery这个词，然后我死活都搞不清楚这个东西到底是什么、和JS是怎样一种关系。对于已经能够编程、特别是科班出身的人而言，这种困惑可能相当可笑，但当时我真的绞尽脑汁搞不懂什么叫“库”。这种概念上的混乱、无知，比学习JS过程中的任何具体困难都更加挫败我。\r\n\r\n这家公司并不是技术导向型的，事实上，包括我在内，整个公司只有两名程序员，如果我也算得上程序员的话。在这里我工作了两年多，工作里没有任何学习的空间，到我离开的时候，我仍然没什么长进，只会用JS做一些最最基本的DOM操作。最大的收获，可能是因为公司网站需要兼容到IE6，而学会了各种各样兼容旧浏览器的奇技淫巧。\r\n\r\n去年10月份，我开始了我的第二份编程工作。这一次我进入了一家技术主导的公司，但也只是理论上如此。在我入职的时候，如果不算实习生的话，整个公司就只有我一个程序员。然而正是在这里，因为“环境所迫”，我体内好像也有个小宇宙，突然爆发了。在这一年之内，我从一个写最基本的jQuery都有问题的垃圾程序员、变成现在这个用半天的时间学会使用VueJS的我。\r\n\r\n开始的前两、三个月里，我都专注在jQuery上。一开始写一个再简单的效果都要跟着教程一步一步来，后来慢慢地找到感觉了，能够一举三反，大多数普通的页面效果都能自己想出办法来实现。这时候是我第一次真正觉得自己像个程序员。期间首回碰到要写动态交互的情况，我对ajax是什么一窍不通，吓得周末回家什么都不干，就只顾着到处找相关的资料来学习。\r\n\r\n后来公司里做后端的同事向我介绍了Angular，我简单了解了以后觉得特别深奥，心想还是等我把基础学扎实了再来搞懂这东西吧。但后来碰到一个非常复杂的页面，同事说你不用Angular这种框架来写代码会乱死、人会累死，最后我没办法只好硬着头皮上了。就是这一次，我体会到一个往后仍然不断应验的道理：很多东西都不是在细腻的计划里学会的，而恰恰是在各种混乱的实践之中搞明白的。于是接下来的一两个月里，我大量地接触Angular，在似懂非懂的情况下勉强学会了使用我的第一个前端框架。这时候的我不但知道“库”是什么，我还知道“库”和“框架”的区别是什么，这让我很有成就感。\r\n\r\n再后来我从订阅的相关网站里听说了React，有点跃跃欲试。有天晚上大家都下班了，我就一个人待在办公室里折腾，下载Node.js、用npm安装各种依赖、写最新的语法、使用webpack编译和打包代码。我不是特别喜欢React的风格（好像和我对Facebook的偏见有关系），但学习React带我进入了前端领域真正的大世界。一开始我还没搞清楚状况，只知道跟着教程安装这个、配置那个，等到我从中学会很多概念回过神来的时候，才恍然大悟：我终于跟世界接轨了。我莫名其妙踏入了那个“高级”的JS社区，从此以后，订阅的网站里所讨论的这个那个趋势、这个那个技术，我终于都有点头绪了。\r\n\r\n接下来我开始了疯狂的学习历程。虽说“疯狂”，但我完全不觉得劳累。一方面是因为我很享受；另一方面是意识里其实一直有所节制，不想让自己成为工作狂。总之我几乎每天晚上下班后都会学习，有时候一整天下来什么东西也没学就会觉得特别空虚、焦躁。这个过程里，最重要的可能是我花时间学习了大量Javascript的基础知识，这比学习任何一个新的WEB API或新框架都重要得多。\r\n\r\n之后我系统地学习了git的使用，接触了Typescript、Less、Rollup等等东西。这后来最重要的一个里程碑，应该是我学会了使用Node.js。不是使用它辅助前端开发，而是真真正正地使用它编写后端代码。上一个月，我独立使用Node.js、MongoDB和Vue为公司搭建了一个内部使用的系统，现在已经是我们公司研发部门每日必不可少的依赖。\r\n\r\n这就是我的2016，一段出乎我自己意料的成长。更重要的是，我变得非常开心。我再也没有一天是害怕上班的，我很享受工作，也得到很好的报酬。我的日常情绪有了很大的改善。\r\n\r\n想起来有些奇幻。大学寝室里某天熄灯以后，我搬着椅子坐在走廊里看《CSS权威指南》，别人走过去都问我这么拼命做什么，看清楚我看的书目后更是莫名其妙不知所谓。那时候的我大概也没预料到，这些奇奇怪怪的代码有一天将会改变我的生活，我会成为一个程序员，并且还算擅长这件事。\r\n\r\n如果我身上还有什么关于工作的难题需要解决，那大概是英语里所说的impostor syndrome。我肯定自己的能力，并且相信自己现在是一个起码称职的程序员。但根本上，我仍然是一个有些保守、不自信的人。有时候阅读别人的文章，感到自己跟别人比简直什么都算不上，总觉得自己写的代码在别人看来都特别幼稚、可笑，没有任何技术含量。\r\n\r\n面试的时候，如果一家公司开出A到B的工资，然后问我期望值，我几乎笃定会回答A，然后还觉得有些配不上因而不好意思。我想让自己大气一点，事实上敢夸海口的人得到的机会更多，但还是无论如何都说不出口类似“我JS水平很好”、“我精通CSS”这种话。有一天我仔细想了这个事，最后发现在我所设想的情境里，我宁愿拐弯抹角地跟面试官说“我这方面的能力只能算掌握了基础，但我这个人一般把自己评估得比较保守”，也不敢直接说“我觉得我应该在平均水准以上”。\r\n\r\n今年年中，因为种种原因，我想接受另一个公司的入职邀请。我目前所在公司的老板知道后，直接给我翻了一倍工资，用一个在我所在的城市算得上很大的数字挽留我，我才知道我值这个价钱。但这对“治疗”我的骗子综合症没有什么太大的帮助。\r\n\r\n也许以后我会继续长进，直到有一天我的水平终于让我不再以自己的代码为耻，不再以为自己是个配不上自己工资的冒牌货。也许不会。\r\n\r\n但我真的很开心我成为了一个程序员，从事着我非常热爱的事情。所以，最后还是要对今天的自己说一声：\r\n\r\n<pre><code class=\"language-javascript\">\r\n  console.log('你好，骗子');\r\n</code></pre>"
  },
  {
    "name": "nodejs-generate-static-site",
    "title": "用Node.js编写一个简单的静态站点生成器",
    "date": " 2017-01-11",
    "tags": [
      "技术"
    ],
    "content": "搭建一个博客有很多种办法。作为一个Web开发人员，我倾向于尽可能地“自己动手丰衣足食”。\r\n\r\n考虑到我目前唯一熟悉的语言是Javascript，我希望这个博客的后端是基于Node.js的，所以首先排除了Wordpress一类的方案。  \r\n一个简单的博客，所需要实现的后端功能并不复杂。虽然我从事的是前端开发，但我感觉这种程度的后端代码应该在我的能力范围之类，因此也没有直接采用Ghost这种使用Node.js编写的CMS。\r\n\r\n现在似乎流行一种静态的博客搭建方案，不使用数据库，而是通过某种办法直接从纯文本生成最终的静态页面。比较具有代表性的平台应该是GitHub Pages。  \r\n我了解到Github Pages使用的是一个叫Jekyll的生成器。虽然我并不准备把我的博客托管在GitHub Pages上，但把它的生成器借来用一用应该还是不错的。Jekyll是开源的。但仔细了解后，发现Jekyll是用Ruby写的，我的胃口马上没了。\r\n\r\n最终我回归了传统的方式，使用Node.js上的express框架、以及MongoDB作为数据库，编写了这个博客的第一个版本。\r\n\r\n### 使用数据库的问题\r\n\r\n就展示文章而言，数据库的操作非常简单，无非是查查文章、分分页面。  \r\n但怎么把文章发出去就有些麻烦了。我需要专门在前端写一个界面来管理和发布文章，事实上我也确实用Angular写了这么一个应用。为了使用起来舒服，我不得不花时间把它“设计”得漂亮一些；为了安全性，我必须在前后端交互的时候设置一些口令之类的东西。总的来说，感觉很不轻量。只是为了发布一篇文章却要额外做许多事情。  \r\n这时候，那种静态的方案又开始在我的脑子里蹦来蹦去了。对一个开发人员而言，只需要写一个Markdown文档就能完成文章的发布，确实是一个很有吸引力的做法。\r\n\r\n### 基于JS的第三方生成器\r\n\r\n在Jekyll以外，其实还有很多很多的[静态站点生成器](https://www.staticgen.com)。其中有不少是使用JS编写的。我试用了其中比较流行的一个，发现它非常复杂。  \r\n这种复杂主要不是指使用上的难度（虽然确实有些麻烦），而是它做了很多你并不需要它去做的事。当然，作为一个通用方案，它必须考虑各种各样的使用场景，这没有问题。但如果你需要的只是一个简单的核心功能，使用这样的第三方工具就有种杀鸡用牛刀的笨重感，即没有必要也不灵活。\r\n\r\n### 自己动手丰衣足食\r\n\r\n我不清楚这些第三方的生成器究竟做了多少事情、怎么做的，但我一开始接触这个概念时，我就直觉它实现起来非常简单。  \r\n最终我自己用Node.js写了一个脚本来实现这个功能，整个脚本算上空行也只有38行。当然，我的实现肯定不如成熟的第三方方案来得完备、可靠，但对这个简单的个人博客来说，真的已经够用了。\r\n\r\n### 实现\r\n\r\n在动手写代码之前，先思考一下我们到底需要一个怎样的功能。\r\n\r\n我的设想是这样的：\r\n\r\n1. 我有一个专门的文件夹用来放置我的博客文章，每一篇文章分别是一个Markdown文档，我需要一个脚本把这些Markdown文档自动转换为HTML文档\r\n2. 我将事先拥有一个HTML模板，这个模板包含了文章以外的内容，这些内容对于每个文章页面都是不变的\r\n3. 我会使用一个第三方的工具来做Markdown到HTML的转换，把转换后的内容插入模板内，在预定的目录里写入一个对应的HTML文件\r\n\r\n<pre><code class=\"language-javascript\">\r\n  const fs = require('fs');\r\n  const path = require('path');\r\n  const marked = require('marked');\r\n\r\n  const POST_DIR_PATH = 'path/to/posts';\r\n  const filenames = fs.readdirSync(POST_DIR_PATH);\r\n  const template = fs.readFileSync('/path/to/tempalte', 'utf-8');\r\n\r\n  filenames.forEach((filename) => {\r\n    const postMarkdown =  fs.readdirSync(path.join(POST_DIR_PATH, filename), 'utf-8');\r\n    const postHTML = marked(postMarkdown);\r\n    const html = template.replace(/\\{post\\}/, postHTML); // 这里只是简单地查找替换，更复杂的情况可以使用成熟的第三方模板\r\n    fs.writeFileSync('/path/to/html', html);\r\n  });\r\n</code></pre>\r\n\r\n为了便于阅读，上面代码里涉及到文件操作的，都使用了同步的方式。  \r\n这样短短的一段代码就已经能基本实现我们所设想的功能了。\r\n\r\n不过这里有一个问题是，除了文章详情页，我们的博客还需要每一页的文章列表。另外，我这个博客的列表页还有用标签筛选的功能。  \r\n我们当然可以编写额外的代码来生成这些列表页面，但文章和标签一多的话，这种做法感觉上就有点累赘。想来想去，最后我决定把Markdonw文件里提取出的内容以数组的形式写入一个json文件里，而不是直接生成HTML文件。生成HTML文件的步骤可以放到服务器的请求里。\r\n\r\n<pre><code class=\"language-javascript\">\r\n  // ...\r\n\r\n  const posts = JSON.parse(\r\n    fs.readFileSync('./posts.json'), 'utf-8')\r\n  );\r\n\r\n  server.get('/', (req, res) => {\r\n    const PER_PAGE = 10; // 每页文章数\r\n    const { p, tag } = req.query; // 请求的页数和标签\r\n\r\n    const startIndex = p ? PER_PAGE * (p - 1) : 0;\r\n    const result = posts\r\n      .filter(post => !tag || post.tags.includes(tag)) // 用标签做筛选\r\n      .sort((a, b) => new Date(b.date) - new Date(a.date)) // 按时间排序\r\n      .slice(startIndex, startIndex + PER_PAGE); // 分页\r\n\r\n    // 把文章数据扔进ejs模板里\r\n    res.render('index', {\r\n      posts: result.map(post => markPost(post, true)),\r\n    });\r\n  });\r\n</code></pre>\r\n\r\n由于我在列表页必须显示文章的摘要，因此Markdown到HTML的转换（markPost）也放到服务器请求里操作。\r\n\r\n实际代码里我们应用使用异步的方式来操作文件读写，这样性能更好。  \r\n这里我使用Promise封装Node.js的原生方法，然后使用Promise.all来控制流程。完整的代码如下：\r\n\r\n<pre><code class=\"language-javascript\">\r\n  const fs = require('fs');\r\n  const path = require('path');\r\n\r\n  const POST_DIR_PATH = 'path/to/posts';\r\n\r\n  // 处理读取出来的Markdown文本\r\n  const getPostInfo = (filename, postStr) => {\r\n    // 提取Markdown文档的文件名，作为文章详情页的url路径\r\n    // 在Markdonw文档里按自己喜欢的格式定义好标题、日期、标签，在这一步把它们抽取出来\r\n    const matches = postStr.match(/%TITLE\\s*(.*)\\s*%DATE(.*)\\s*%TAGS\\s*(.*)\\s*([\\s\\S]*)/);\r\n    return {\r\n      name: path.basename(filename, '.md'),\r\n      title: matches[1],\r\n      date: matches[2],\r\n      tags: matches[3].split(','),\r\n      content: matches[4],\r\n    };\r\n  };\r\n\r\n  // 用Promise封装fs.readFile\r\n  const readPost = filename => new Promise((resolve, reject) => {\r\n    fs.readFile(filename, 'utf-8', (error, str) => {\r\n      if (error) {\r\n        reject(error);\r\n      } else {\r\n        resolve(getPostInfo(filename, str));\r\n      }\r\n    });\r\n  });\r\n\r\n  // 读取Markdown文件\r\n  const filenames = fs.readdirSync(POST_DIR_PATH);\r\n  Promise.all(\r\n    filenames.map(filename => readPost(path.join(POST_DIR_PATH, filename)))\r\n  )\r\n    .then((posts) => {\r\n      fs.writeFileSync(\r\n        path.resolve(__dirname, 'posts.json'),\r\n        JSON.stringify(posts, null, 2)\r\n      );\r\n    })\r\n    .catch(error => console.log(error));\r\n</code></pre>"
  },
  {
    "name": "pronunciation-of-ts",
    "title": "怎么音译外语中的ts",
    "date": " 2017-01-17",
    "tags": [
      "语言"
    ],
    "content": "昨日澳网开赛了。  \r\n据说在央视的转播中有一个插曲：解说员现场指导工作人员，把Tsurenko这个名字的翻译从“特苏仑科”更正为“苏仑科”。\r\n\r\nTsurenko是一名来自乌克兰的网球运动员，其姓氏在乌克兰语中拼作Цуренко。如果仔细对照的话，会发现西里尔原文比拉丁转写少用了一个字母。这是因为转写后的ts，在原文里只用Ц一个字母来表示。  \r\n那么这个Ц/ts到底怎么读呢？其实它就相当于汉语拼音中的c（<a href=\"#comment1\">注1</a>）。这样一个普通话中现成的发音，在翻译中却经常闹错误。我不只一次在央视的译名里看到这种把ts拆着翻的做法，另一个例子是法国网球运动员Tsonga，被译作“特松加”。\r\n\r\n汉语拼音的c这个声母，国际音标作/ts/。\r\n\r\n比较主流的外语里，要么碰不到/ts/这个发音，比如法语、西班牙语；要么这个发音在该语言中并不拼做ts，比如德语和意大利语的正字法中都把此音拼做z。\r\n\r\n英语比较特殊。英语中既可以听到/ts/这个音，而且拼写上确实也对应ts这两个字母。比如cats，在说普通话的人听来，会觉得最后的-ts听起来就像是普通话中的“次”。  \r\n但仔细说起来又有点复杂。你在任何的英语发音材料里，大概都是找不到/ts/这个音的。你去叫一个说英语的人读汉语的“次”，他很可能根本读不出来。这又是为什么？\r\n\r\n如同它的国际音标符号所展示的那样，/ts/这个音，根本上就是一个/t/和一个/s/紧密地结合在一起。在有些语言中，比如普通话里，这个结合后的发音被认知为一个单独的发音，可以（在该语言允许的范围里）自由地和其它音素拼读。  \r\n但英语里的/ts/则非如此。英语的/ts/音不是一个独立的辅音音位，英语中t和s这两个字母一般也不会一起出现，只在某些特殊情况下，当t和s刚好碰在一起时才会产生/ts/这个发音。虽然cats中的-ts在说普通话的人听来是“次”；但对说英语的人而言，它们仍然是两个各自独立的辅音。  \r\n所以你让讲英语的人单独发出/ts/这个音，是有困难的，他们母语以及他们的认知里，都没有这样的一个音。如果你要指导他们发这个音，可能你必须告诉他，“把/t/和/s/这两个音连结在一起快速地发出来”之类的。\r\n\r\n什么时候英语里的t和s会恰好一起出现呢？最常见的就是本来以-t结尾的单词，加上表示复数的-s。而有一种地方是绝对不会出现ts的，那就是词首。  \r\n对于意大利语的pizza这种外来词，说英语的人可以把它的发音理解成PEET-suh，t属于前一个音节，s属于后一个音节，但两个音节连在一起快速读出来，t和s就合成/ts/一个音了，这样就模拟出了原意大利语发音中/ts/音（<a href=\"#comment2\">注2</a>）。  \r\n不过碰到日语的tsunami这样的词时就没办法了，词首的ts-无法拆分到两个音节里，而说英语的人又没办法把ts当成一个整体的辅音来读，因此他们就只能把它读成sunami。\r\n\r\n回到译名的问题。  \r\n\r\n明明是一个普通话里现成的音，汉语媒体却没办法把它翻译正确，这主要应该有以下两个原因：\r\n1. /ts/这个发音在汉语拼音或其它使用拉丁字母的主流语言里都不拼做ts，导致我们的认知里ts这两个字母和普通话的c声母没有联系，不知道ts常常表示的就是汉语拼音的c这个音。\r\n2. 英语是最主流的外语，由于说英语的人难以发出词首的/ts/音，导致被英语媒体所影响的我们也不知道词首的ts-发的是汉语拼音的c音。甚至被说英语的人牵着鼻子走，以为这种地方的t不发音。央视的解说员把“特苏仑科”纠正为“苏仑科”就是这种情况，纠正前只能说是不精确、不恰当，纠正后反而错得更离谱了。\r\n\r\n也许哪天央视的工作人员会醒悟过来，发现这个他们百思不得其解的音译问题，其答案其实远在天边、近在眼前。\r\n\r\n### 注\r\n<ol>\r\n<li id=\"comment1\">实际上既相当于汉语拼音的z也相当于汉语拼音的z，这里涉及到普通话区分送气而不区分清浊的问题。但这不是本文的重点，为了不分散讨论，文中把相关的描述都简化了。</li>\r\n<li id=\"comment2\">实际上这里应该是一个长辅音/tts/。但同样的，这不是本文的重点，不作讨论。</li>\r\n</ol>\r\n\r\n### 参考\r\n* [Wikipedia - Lesia Tsurenko](https://en.wikipedia.org/wiki/Lesia_Tsurenko)\r\n* [Wikipedia - Jo-Wilfried Tsonga](https://en.wikipedia.org/wiki/Jo-Wilfried_Tsonga)\r\n* [Wikipedia - Ukrainian alphabet # Letter names and pronunciation](https://en.wikipedia.org/wiki/Ukrainian_alphabet#Letter_names_and_pronunciation)"
  }
]