{"version":3,"sources":["sw.js"],"names":["const","CACHE_NAME","urlsToCache","self","addEventListener","event","waitUntil","caches","open","then","cache","addAll","keys","Promise","all","filter","key","map","delete","request","method","respondWith","fetch","cacheTheResponse","res","status","type","clonedRes","clone","put","match","cachedRes","networkedRes","catch","Response","statusText"],"mappings":"AAAAA,GAAMC,YAAa,kBACbC,aACJ,IACA,iBACA,gBACA,iBACA,eAGFC,MAAKC,iBAAiB,UAAW,SAAAC,GAC/BA,EAAMC,UACJC,OACGC,KAAKP,YACLQ,KAAK,SAAAC,GAAA,MAAAA,GAAKC,OAACT,kBAIlBC,KAAKC,iBAAiB,WAAY,SAAAC,GAChCA,EAAMC,UACJC,OAAOK,OACJH,KAAK,SAAAG,GAAA,MAAAC,SAAKC,IACTF,EACGG,OAAO,SAAAC,GAAA,MAAAA,KAAIf,aACXgB,IAAI,SAAAD,GAAA,MAAAT,QAAGW,OAACF,WAKnBb,KAAKC,iBAAiB,QAAS,SAAAC,GAC7B,GAAQc,GAAOd,EAAAc,OAGf,IAAuB,QAAnBA,EAAQC,OACV,MAAOf,GAAMgB,YAAYC,MAAMH,GAGjCnB,IAAMuB,GAAmB,SAAAC,GAEvB,IAAKA,GAAsB,MAAfA,EAAIC,QAA+B,UAAbD,EAAIE,KACpC,MAAOF,EAGTxB,IAAM2B,GAAYH,EAAII,OAMtB,OALArB,QACGC,KAAKP,YACLQ,KAAK,SAAAC,GACJA,EAAMmB,IAAIV,EAASQ,KAEhBH,EAGT,OAAOnB,GAAMgB,YACXd,OAAOuB,MAAMX,GACVV,KAAK,SAAAsB,GACJ/B,GAAMgC,GAAeV,MAAMH,GACxBV,KAAKc,GAELU,MAAM,WAAA,MAAA,IAAAC,UAAG,IACRT,OAAQ,IACRU,WAAY,yBAIhB,OAAOJ,IAAaC","file":"sw.js","sourcesContent":["const CACHE_NAME = 'A-TALK-TO-ME-V1';\r\nconst urlsToCache = [\r\n  '/',\r\n  '/lib/prism.css',\r\n  '/lib/prism.js',\r\n  '/css/style.css',\r\n  '/js/speak.js',\r\n];\r\n\r\nself.addEventListener('install', (event) => {\r\n  event.waitUntil(\r\n    caches\r\n      .open(CACHE_NAME)\r\n      .then(cache => cache.addAll(urlsToCache))\r\n  );\r\n});\r\n\r\nself.addEventListener('activate', (event) => {\r\n  event.waitUntil(\r\n    caches.keys()\r\n      .then(keys => Promise.all(\r\n        keys\r\n          .filter(key => key !== CACHE_NAME)\r\n          .map(key => caches.delete(key))\r\n      ))\r\n  );\r\n});\r\n\r\nself.addEventListener('fetch', (event) => {\r\n  const { request } = event;\r\n\r\n  // should only intercept GET requests\r\n  if (request.method !== 'GET') {\r\n    return event.respondWith(fetch(request));\r\n  }\r\n\r\n  const cacheTheResponse = (res) => {\r\n    // don't need to cache response if the request is failed\r\n    if (!res || res.status !== 200 || res.type !== 'basic') {\r\n      return res;\r\n    }\r\n\r\n    const clonedRes = res.clone();\r\n    caches\r\n      .open(CACHE_NAME)\r\n      .then((cache) => {\r\n        cache.put(request, clonedRes);\r\n      });\r\n    return res;\r\n  };\r\n\r\n  return event.respondWith(\r\n    caches.match(request)\r\n      .then((cachedRes) => {\r\n        const networkedRes = fetch(request)\r\n          .then(cacheTheResponse)\r\n          // TODO: return an offline page when there is no cache nor network\r\n          .catch(() => new Response('', {\r\n            status: 503,\r\n            statusText: 'Service Unavailable',\r\n          }));\r\n\r\n        // will return cache if there is one, otherwise it will return the normal request result\r\n        return cachedRes || networkedRes;\r\n      })\r\n  );\r\n});\r\n"]}